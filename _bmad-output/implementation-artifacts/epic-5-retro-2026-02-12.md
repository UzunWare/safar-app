# Epic 5 Retrospective: Progress Tracking & Engagement

**Date:** 2026-02-12
**Facilitator:** Bob (Scrum Master)
**Epic:** Epic 5 - Progress Tracking & Engagement
**Status:** Complete (6/6 stories done)
**Model:** Claude Opus 4.6

## Team Participants

- Alice (Product Owner)
- Bob (Scrum Master) - Facilitator
- Charlie (Senior Dev)
- Dana (QA Engineer)
- Elena (Junior Dev)
- Emrek (Project Lead)

## Epic Summary

### Delivery Metrics

- **Stories Completed:** 6/6 (100%)
- **Implementation Period:** Feb 11-12, 2026
- **Test Suite Growth:** ~592 tests (start) → 838 tests (end), +246 new tests
- **FRs Covered:** FR31 (words learned count), FR32 (pathway completion %), FR33 (mastered words), FR34 (daily streak), FR35 (streak display), FR36 (streak freeze), FR37 (XP awards), FR38 (XP display), FR39 (streak notifications), FR40 (review notifications)

### Quality Metrics

- **Code Reviews Performed:** 6 adversarial reviews (all stories)
- **Total Issues Found:** ~30+ (4 CRITICAL, 10+ HIGH, 10+ MEDIUM)
- **Issues Fixed:** All issues resolved before story marked done
- **Re-reviews:** Stories 5.2, 5.3, 5.4 required re-review after fixes; all approved on second pass
- **Test Coverage:** 246 new unit/component/hook tests across 6 stories
- **Regression:** Zero regressions — full 838-test suite green throughout

### Stories Delivered

| Story | Title | Agent | Tests Added | Review Findings | Re-review |
|-------|-------|-------|-------------|-----------------|-----------|
| 5-1 | Progress Dashboard | Opus 4.6 | 34 | 3 HIGH, 2 MED | No (fixed in-pass) |
| 5-2 | Streak Tracking | Opus 4.6 | 46 | 3 HIGH, 2 MED | Yes → Approved |
| 5-3 | Streak Freeze | Opus 4.6 | 36+ | 2 CRIT, 1 HIGH, 2 MED | Yes → Approved |
| 5-4 | XP Points System | Opus 4.6 | 50+ | 4 HIGH, 2 MED | Yes → Approved |
| 5-5 | Push Notifications (Streak) | Opus 4.6 | 54 | HIGH findings (fixed in-flow) | No (approved) |
| 5-6 | Push Notifications (Review) | Opus 4.6 | 42 | 3 HIGH, 2 MED | No (fixed in-flow) |

## Successes

### 1. 100% Story Completion with Full FR Coverage

All six stories delivered and reviewed, covering FR31-FR40 completely. The engagement system is fully functional: progress dashboard, streak tracking with freeze protection, XP gamification, and dual push notification systems (streak + review reminders).

### 2. Composable Architecture Patterns

Story 5.2's streak utilities (`calculateStreakStatus`, `shouldIncrementStreak`) became the foundation for Story 5.3's freeze logic. Story 5.5's notification infrastructure (service, preferences, scheduler, orchestrator, handler) was seamlessly reused by Story 5.6. Building composable, well-separated modules accelerated later stories.

### 3. Massive Test Suite Growth

246 new tests across 6 stories represents the most test-intensive epic yet. Key test patterns established:
- Hook testing with TanStack Query mocking
- AsyncStorage mock isolation (explicit `mockImplementation` reset in `beforeEach`)
- Notification scheduling verification with trigger type assertions
- Date/timezone boundary testing with local date helpers

### 4. Adversarial Review Effectiveness

Every story underwent adversarial review. The review process caught runtime wiring gaps (3 stories), atomicity issues (Story 5.4), timezone bugs (Story 5.2), stale state edge cases (Stories 5.2, 5.3), and task completion accuracy issues (Story 5.4). The review → fix → re-review cycle produced genuinely production-quality code.

### 5. Consistent Design System Adherence

All components follow Divine Geometry design system: ProgressRing (emerald/gold), StreakCounter (flame icon, gold tones), XpDisplay (gold star), StreakFreezeButton (gold available, muted unavailable), FreezeConfirmModal (emerald overlay). No generic blue/gray/red colors used.

### 6. Empathetic UX Design

Story 5.2 established the "no shame" messaging pattern for broken streaks: "Welcome back! Your knowledge is still here. X words ready for review." This carries through to notifications (non-guilt-tripping reminders) and freeze confirmation ("Streak preserved! Learn tomorrow to continue.").

## Challenges

### 1. Runtime Wiring Gaps (3/6 Stories)

The most significant recurring issue: code modules were built and tested in isolation but not connected to actual app lifecycle flows.

- **Story 5.4:** `syncPendingXp` function existed but was never called from runtime code
- **Story 5.5:** Notification scheduling wasn't wired into `_layout.tsx`, completion flows, or profile settings
- **Story 5.6:** Same pattern — orchestrator code existed but wasn't integrated into app flows

**Root Cause:** TDD focuses on unit-level behavior. "Function works" ≠ "Function runs in the app." The definition of done didn't explicitly require runtime integration verification.

### 2. Stale State and Edge Cases (4/6 Stories)

Engagement features have inherent temporal complexity. Issues found:

- **Story 5.2:** Broken streaks displayed stale non-zero values in UI
- **Story 5.2:** UTC date formatting (`toISOString().split('T')[0]`) shifted calendar dates for many timezones
- **Story 5.3:** Stale broken streaks could be incorrectly marked as "frozen"
- **Story 5.4:** Non-atomic read-modify-write XP updates vulnerable to concurrent lost updates
- **Story 5.4:** No non-negative constraint on `total_xp` allowed invalid states

**Root Cause:** Temporal state (dates, streaks, freezes) and concurrent state (XP accumulation) require defensive programming patterns that aren't automatically applied by TDD alone.

### 3. Business Rule Enforcement at Wrong Layer (4/6 Stories)

Business invariants were enforced only in UI, not in API/database layers:

- **Story 5.3:** One-freeze-per-week enforced by UI button state, not API validation
- **Story 5.4:** Cumulative XP invariant not enforced by DB constraint until review
- **Story 5.6:** One-notification-per-day limit relied on AsyncStorage, with no bypass for config changes

**Root Cause:** UI-level enforcement is visible and easy to implement. API/DB enforcement requires additional migration or validation code. Without explicit story requirements, the path of least resistance wins.

### 4. Task Completion Accuracy (3/6 Stories)

Tasks were marked `[x]` complete when subtask bullet points weren't fully satisfied:

- **Story 5.4 Task 6:** Marked complete, but review XP animation wasn't implemented
- **Story 5.4 Task 8:** Marked complete, but sync function was never called from runtime
- **Story 5.3 Task 2:** Marked complete, but success confirmation was missing

**Root Cause:** Self-review of task completion checklists was rushed. Each `[x]` should require verifying all indented bullet points.

### 5. AsyncStorage Mock Isolation

Story 5.6 discovered that `jest.clearAllMocks()` doesn't reset `mockResolvedValue` implementations set by individual tests. This caused test order dependencies. Fixed by explicit `mockImplementation` resets in `beforeEach`.

**Impact:** This is a testing infrastructure insight that affects all future stories using AsyncStorage mocks.

## Key Insights

### 1. Code Review Is the Critical Quality Gate

Every story had significant findings caught only by review. The pattern of "build → test → review → fix → re-review" is essential. Without adversarial review, Stories 5.2-5.4 would have shipped with timezone bugs, stale state issues, race conditions, and missing runtime wiring.

### 2. "Works in Tests" ≠ "Works in App"

The runtime wiring gap pattern reveals a blind spot in TDD methodology. Unit tests prove component behavior in isolation. Integration verification (is this actually called in the app?) requires either:
- Integration tests that mount the full app
- An explicit "runtime wiring checklist" in the definition of done
- Review checklist item: "verify all new functions are called from app code"

### 3. Engagement Features Are State-Intensive

Streaks, freezes, XP, and notifications all involve temporal logic, cross-session persistence, and multiple interacting systems. The complexity isn't in any single story but in how they compose. Story 5.3 (freeze) modified streak logic from 5.2. Story 5.6 (review notifications) reused infrastructure from 5.5. Each increment added edge cases to the combined system.

### 4. Composable Module Architecture Accelerated Delivery

Despite the challenges, the modular architecture paid off significantly. Story 5.6 was able to build on 5.5's notification infrastructure with minimal friction. The separated concerns (scheduler for low-level API, orchestrator for business logic, handler for routing) made each module independently testable and composable.

### 5. Defensive Database Design Prevents Silent Failures

Story 5.4's non-negative XP constraint and atomic RPC increment pattern should be the standard for all user-facing counters. Story 5.2's race-safe streak initialization (handling `23505` unique constraint conflicts) shows that concurrent-safe patterns need to be the default, not an afterthought.

## Previous Retrospective Follow-Through

**Epic 2 Retro Action Items:**

| # | Action Item | Status | Evidence |
|---|-------------|--------|----------|
| 1 | Enforce "tests required" in definition of done | ✅ Completed | All 6 stories shipped with 246 new tests |
| 2 | Ban type assertions (`as Type`, `as any`) | ⏳ In Progress | Not flagged in any Epic 5 review, but not explicitly tracked |
| 3 | No console.log in production code | ✅ Completed | Not flagged in any Epic 5 review |

**Epic 2 Technical Debt:**

| # | Debt Item | Status | Impact on Epic 5 |
|---|-----------|--------|------------------|
| 1 | Story 2-1 zero test coverage | ❌ Not Addressed | No direct impact on Epic 5 |
| 2 | Manually maintained TypeScript types | ❌ Not Addressed | Types for user_streaks, user_xp added manually — drift risk compounds |
| 3 | Story numbering mismatch | ❌ Not Addressed | Low priority, cosmetic |

**Epic 2 Team Agreements:**

| Agreement | Followed? | Evidence |
|-----------|-----------|----------|
| Every story gets adversarial review | ✅ Yes | All 6 stories reviewed, 3 required re-review |
| Offline-first: read AND write AsyncStorage | ✅ Yes | Dashboard cache, streak cache, XP pending queue, notification prefs |
| Architecture doc authoritative for storage | ✅ Yes | No storage decision violations found |

**Summary:** Process improvements from Epic 2 were well-adopted (2/3 action items complete, 3/3 agreements followed). Technical debt items all carried forward — the type generation debt is growing with each new table.

## Next Epic Preview: Epic 6 - Subscription & Monetization

### Epic Overview

Epic 6 introduces RevenueCat for in-app subscriptions. 7 stories covering:
1. Free trial & RevenueCat setup
2. Subscription options display
3. Purchase flow
4. Paywall enforcement
5. Purchase restoration
6. Subscription management

### Dependencies on Epic 5

- Notification preferences system (for trial expiration reminders, if needed)
- Settings infrastructure (profile screen, preference toggles)
- AsyncStorage patterns for subscription state caching
- App lifecycle hooks (for entitlement checking)

### Key Differences from Previous Epics

1. **External SDK dependency:** RevenueCat is our first revenue-critical external integration
2. **Platform-specific:** StoreKit 2 (iOS) and Play Billing (Android) behave differently
3. **Financial impact:** Bugs directly affect revenue and user trust
4. **App Store compliance:** Required disclosures, restore purchases button, subscription terms
5. **Testing complexity:** Sandbox environments needed for purchase testing

### Potential Risks

- RevenueCat SDK integration may surface Expo compatibility issues
- Subscription state management is inherently complex (trial, active, expired, grace period)
- App Store review rejection risk if compliance requirements missed
- No existing patterns for paywall enforcement or entitlement checking

## Action Items

### Process Improvements

| # | Action | Owner | Success Criteria |
|---|--------|-------|-----------------|
| 1 | Add "runtime wiring verification" to definition of done | Bob (SM) | Every story's DoD includes "verify all new functions are called from app code" |
| 2 | Enforce business rules at API/DB layer, not just UI | Charlie (Dev) | Review checklist includes "invariants enforced in database or API validation" |
| 3 | Require explicit subtask verification before marking tasks complete | Bob (SM) | Dev must verify each bullet point under `[x]` before marking done |
| 4 | Add AsyncStorage mock reset pattern to test setup documentation | Dana (QA) | Standard `beforeEach` includes explicit `mockImplementation` resets |

### Technical Debt

| # | Item | Owner | Priority | Notes |
|---|------|-------|----------|-------|
| 1 | Manually maintained TypeScript types (carried from Epic 2) | Charlie (Dev) | High | Growing with each new table; affects Epic 6 subscription tables |
| 2 | Story 2-1 zero test coverage (carried from Epic 2) | Dana (QA) | Medium | Onboarding flow untested |
| 3 | `@sentry/react-native` still mocked, not installed | Charlie (Dev) | Low | Not blocking but accumulating |
| 4 | No integration tests against real Supabase (carried from Epic 2) | Dana (QA) | Medium | All tests are mocked |

### Team Agreements

- **Runtime wiring is part of "done":** A function that exists but isn't called from app code is not complete
- **Defensive state management:** Use atomic operations, DB constraints, and API validation for all user-facing counters and state
- **Edge case first:** When implementing temporal logic (dates, streaks, timers), write edge case tests before happy path
- **Mock isolation:** Always reset AsyncStorage mocks explicitly in `beforeEach`, not just via `clearAllMocks()`

## Epic 6 Preparation Tasks

### Critical (Before Epic Starts)

| Task | Owner | Notes |
|------|-------|-------|
| Research RevenueCat Expo SDK compatibility | Charlie | Verify `react-native-purchases` works with Expo SDK 54 managed workflow |
| Set up RevenueCat dashboard (test) | Emrek | Create test products, configure offerings |
| Create `useSubscription` hook skeleton | Charlie | Establish patterns for entitlement checking before stories begin |

### Parallel (During Early Stories)

| Task | Owner | Notes |
|------|-------|-------|
| Set up App Store Connect sandbox testing | Emrek | Needed for purchase flow testing |
| Set up Google Play Console test tracks | Emrek | Needed for Android purchase testing |
| Research paywall patterns in React Native | Elena | UX patterns for subscription screens |

### Nice-to-Have

| Task | Owner | Notes |
|------|-------|-------|
| Generate `supabase.types.ts` from live schema | Charlie | Address the growing type drift debt |
| Add integration test for notification → review flow | Dana | End-to-end notification deep-linking |

## Critical Path

1. **Verify RevenueCat + Expo SDK 54 compatibility** → Must confirm before Story 6-1
2. **RevenueCat dashboard setup with test products** → Blocks Story 6-1 implementation
3. **App Store Connect / Play Console configuration** → Blocks Story 6-3 (purchase flow) testing

## Readiness Assessment

| Area | Status | Notes |
|------|--------|-------|
| Testing & Quality | ✅ Pass | 838/838 tests passing, all review issues resolved |
| Deployment | Not deployed | No production Supabase — same as Epic 2 status |
| Technical Health | ✅ Good | Clean codebase, consistent patterns, zero regressions |
| Unresolved Blockers | RevenueCat research | Need to verify SDK compatibility before Epic 6 starts |

## Significant Discoveries

No discoveries from Epic 5 that fundamentally change Epic 6's plan. The architecture already specifies RevenueCat integration patterns. The notification and settings infrastructure from Epic 5 provides a solid foundation for subscription status displays and trial reminders.

## Commitments Summary

- **Action Items:** 4 process improvements
- **Technical Debt:** 4 items tracked (2 carried from Epic 2)
- **Preparation Tasks:** 6 (3 critical, 2 parallel, 1 nice-to-have)
- **Critical Path Items:** 3
- **Team Agreements:** 4 new agreements

## Next Steps

1. Verify RevenueCat + Expo SDK 54 compatibility
2. Set up RevenueCat dashboard with test products
3. Begin Story 6-1 (Free Trial & RevenueCat Setup) when prep is complete
4. Review these action items in next standup
5. Start creating Story 6-1 detailed file via SM agent's create-story workflow
